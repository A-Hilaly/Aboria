[section Particle Container]

[section Creating new particles]

The main particles data-structure, or container, is called [classref 
Aboria::Particles]. It is templated using a tuple of variable types, explained 
below.  For example, the following creates a set of particles which each have 
(along with the standard variables such as position, id etc) a data package 
consisting of one double variable type named scalar.

``
using namespace Aboria;

ABORIA_VARIABLE(scalar,double,"my scalar")
typedef Particles<std::tuple<scalar>> MyParticles;
MyParticles particles();
``

If you wanted each particle to have a potential variable held as a `double`, as 
well as a velocity variable held as a [classref Aboria::double3] vector class, 
then you would write the following

``
ABORIA_VARIABLE(potential,double,"potential energy")
ABORIA_VARIABLE(velocity,double3,"velocity")
typedef Particles<std::tuple<potential,velocity>> MyParticles;
MyParticles particles();
``

Note that there is a special case for boolean variables, which must be 
represented by an integer, rather than a boolean. This is due to the STL 
specialisation of a boolean STL vector, which conflicts with the internal design 
of Aboria. For example, here we can use an 8-bit unsigned integer to stand in 
for the boolean `flag` variable.

``
ABORIA_VARIABLE(flag,uint_8,"my flag variable")
``

You can give the `MyParticles` constructor a single `unsigned int` argument to 
set the random seed for the container:

``
MyParticles particles_with_seed(0);
``

To create new particles simply use the `value_type` of the container type. Each 
particle constructor takes a single [classref Aboria::Vector] type for the 
particle position.

``
typedef MyParticles::value_type MyParticle;
particles.push_back(MyParticle(double3(0,0,0)));
particles.push_back(MyParticle(double3(1,0,0)));
``

[endsect]

[section Multidimensional Data Types]

Aboria provides an internal vector type [classref Aboria::Vector] for types 
representing a vector of dimension `d`. [classref Aboria::Vector] is templated 
on the type of each element and the number of dimensions:

``
Vector<double,3> dim3vector;
``

There are a number of predefined `double`, `int`, and `bool` vector types, up to 
dimension 7, and typedefed by the pattern <type><dim>. E.g. [classref 
Aboria::double3], [classref Aboria::double6], [classref Aboria::int2], [classref 
Aboria::bool5]... 

[endsect]

[section Particle Objects]

The `value_type` of the [classref Aboria::Particles Particles] container is a 
data-structure representing each particle. By default each particle has a 
position, a unique id and a boolean flag indicating if this particle is active 
or not. Use `get<position_d<D>>()` to access the position (where `D` is the 
dimension of the particle object), `get<id>()` for the id and `get<alive>()` for 
the alive flag.

``
MyParticle& particle = particles[0];
typedef double_d<3> position;
std::cout <<"Position = "<<get<position>(particle) << 
   ". Id = "<<get<id>(particle)<< ". Particle is ";
if (get<alive>(particle)) {
   std::cout << "alive. " << "\n";
} else {
   std::cout << "dead. " << "\n";
}
``

You can access the data by templating the `get` function with the variable type, 
for example

``
std::cout << "The scalar data is " << get<scalar>(particle) << "\n";
``
[endsect]

[section Looping through the container]

You can use the indexing operator `Operator[]` to simply loop through the 
container

``
for (int i=0; i < particles.size(); i++) {
   std::cout << "Accessing particle with id = " << get<id>(particles[i]) << "\n";
}
``

Or you can use the normal STL `begin()` and `end()` functions that return random 
access iterators to the beginning and end of the container.

``
for (auto i = particles.begin(); i != particles.end(); i++) {
   std::cout << "Accessing particle with id = " << get<id>(*i) << "\n";
}
``

Or

``
for (auto i: particles) {
   std::cout << "Accessing particle with id = " << get<id>(i) << "\n";
}
``

Or you can use the STL algorithm `for_each`. If you are using a GCC compiler, 
you can turn on the parallel mode to enable this loop to be run in parallel

``
std::for_each(particles.begin(), particles.end(), [](MyParticle& i) {
   std::cout << "Accessing particle with id = " << get<id>(i) << "\n";
});
``

[endsect]

[section Internal Data for Variables]

Each variable is held internally by a STL vector `std::vector`. If you already 
have an iterator to a [classref Aboria::Particles], for example a [classref
Aboria::Particles::iterator] or [classref Aboria::Particles::const_iterator], 
then you can obtain the corresponding iterator to the internal `std::vector` by 
using the [funcref Aboria::get] function. For example,

``
std::vector<size_t>::iterator& ids = get<id>(particles.begin());
``

[endsect]

[section Particle's `value_type` versus `reference`]

When you index an individual particle using the bracket operator `[]`, it 
returns a [classref Aboria::getter_type getter_type], which is essentially a 
tuple of references to the variables for that particle. This [classref 
Aboria::getter_type getter_type] is `typedef`-ed to [classref
Aboria::Particles::reference], and acts as the reference type for the container.  
Similarly, the [classref Aboria::Particles::value_type value_type] for the 
continer is also a [classref Aboria::getter_type], but instead holds a tuple of 
values instead of references.  

Reading the above paragraph, you will note the fundamental difference from 
normal STL containers, in that [classref Aboria::Particles::value_type 
value_type]& is *not the same* as [classref Aboria::Particles::value_type 
reference].  This is relevant when writing functors for STL algorithms, where 
you will need to be sure if you need a [classref Aboria::Particles::value_type 
value_type]& or a [classref Aboria::Particles::value_type reference].

For example, the `std::sort` algorithm internally stores a `value_type` of an 
element which is used in the comparison, so the functor needs to be equivalent 
to the following

``
bool cmp(const value_type& a, const value_type& b)
``

However, the `std::transform` algorithm can use a `unaryop` functor equivalent 
to

``
Ret fun(const reference a)
``

Which is more efficient than `value_type&`, since dereferencing the iterator 
will result in a `reference`.

[endsect]

[section Important differences from STL containers]

The [classref Aboria::Particles] data structure acts fairly typically like a 
normal STL random-access container, with a few important differences.  It has 
methods like `push_back()`, `clear()`, `size()`, `erase()`.  It provides 
subtypes like `value_type`, `reference`, `const_reference`, `iterator`, 
`const_iterator`. All of the normal algorithms in the standard library *should* 
work with this container, if you find any that don't please let us know and we 
will try to fix this.

The main differences between [classref Aboria::Particles] and normal STL 
containers are:

1. The difference between [classref Aboria::Particles::value_type]& and 
[classref Aboria::Particles::reference] mentioned described earlier.

2. Additional member functions are available to suit the specific purpose of 
this container, for example the [memberref Aboria::Particles::push_back] 
function can take a vector data-type for the particle position, and the 
[Aboria::Particle::get_neighbours] function for neighbour searching.

3.  When using the neighbourhood searching capabilities of the container, the 
order of the particles in the particle container might change due to internal 
sorting for neighbourhood searching efficiency. So do not assume that the 
particle ordering is fixed. For example, the [memberref 
Aboria::Particles::push_back push_back] member function can reorder the 
particles if neighbourhood searching is turned on.

[endsect]

[endsect]


