[section Symbolic Expressions]

[section Symbol Definition]
To start using variable expressions, you first need to define a set of symbols 
to represent your variables, as well as labels to represent your particle 
set(s).

A symbol representing the variable `position` is defined as

``
Symbol<position> p;
``

A label representing the particle set `particles` with type `MyParticles` is 
defined as

``
Label<0,MyParticles> a(particles);
Label<1,MyParticles> b(particles);
``

The first template argument is the *depth* of the label, and the second is the 
type of the particle set label refers to.

Labels refer to a specific particle set at a given depth. For example, given a 
neighbour expression involving two particles from `particles`, the label `a` 
defined above would refer to the first particle, and `b` would refer to the 
second.

[endsect]

[section Constant and Univariate Expressions]

Now we have defined our labels and symbols, we can create a simple expression to 
set the position of all particles to `Vect3d(0,0,1)`

``
p[a] = Vect3d(0,0,1);
``

Or we can add a constant value `1` to each particle position

``
p[a] = p[a] + 1;
``

For symbols on the right hand side of the expression, we can drop the label for 
a more compact expression

``
p[a] = p + 1;
``

Or simply use an increment expression

``
p[a] += 1;
``
[endsect]


[section Bivariate Expressions]

To write expressions involving neighbouring particles, we can define an 
accumulator, which takes a single template argument which is the function or 
functor to accumulate with. For example, the following defines a summation 
accumulator using `std::plus` 

``
Accumulate<std::plus<int> > sum;
``

We can use this to count the number of particles within a distance of `2` of 
each individual particle, storing the result in a variable called `count`.

``
ABORIA_VARIABLE(count,int,"number of surrounding particles")
typedef Particles<count> MyParticles;
MyParticles particles();

//add some particles
...

//initialise neighbour searching
particles.init_neighbour_search(Vect3d(0,0,0),Vect3d(1,1,1),4,Vect3b(false,false,false));

//define symbols and labels, and sum
Symbol<count> c;
Label<0,MyParticles> a(particles);
Label<1,MyParticles> b(particles);
Accumulate<std::plus<int> > sum;

//count neighbouring particles within a distance of 2
c[a] = sum(b,norm(dx)<2,1)
``

[endsect]

[endsect]

