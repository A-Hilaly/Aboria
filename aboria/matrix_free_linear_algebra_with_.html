<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Matrix-free Linear Algebra with Eigen</title>
<link rel="stylesheet" href="../css/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Aboria 0.4">
<link rel="up" href="../index.html" title="Aboria 0.4">
<link rel="prev" href="neighbourhood_searching.html" title="Neighbourhood Searching">
<link rel="next" href="symbolic_expressions.html" title="Symbolic Expressions">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
    },
  TeX: { 
    extensions: ["AMSmath.js", "AMSsymbols.js"] 
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48149829-4', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Aboria" width="200" height="62" src="../images/aboria2.jpg"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="neighbourhood_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="symbolic_expressions.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="aboria.matrix_free_linear_algebra_with_"></a><a class="link" href="matrix_free_linear_algebra_with_.html" title="Matrix-free Linear Algebra with Eigen">Matrix-free Linear
    Algebra with Eigen</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.creating_dense_operators">Creating
      Dense Operators</a></span></dt>
<dt><span class="section"><a href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.creating_sparse_operators">Creating
      Sparse Operators</a></span></dt>
<dt><span class="section"><a href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.block_operators">Block
      Operators</a></span></dt>
<dt><span class="section"><a href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.iterative_solvers">Iterative
      Solvers</a></span></dt>
</dl></div>
<p>
      Given that Aboria can describe non-linear operators, this naturally covers
      linear operators (i.e. matricies) as well. Consider the summation operator
      given by the kernel function $K(x_i,x_j)$, over a set of $N$ particles
    </p>
<p>
      $$ a_i = \sum_j^N b_j K(x_i,x_j) \text{ for } i=1..N $$
    </p>
<p>
      This is a common enough operator that can be used in many areas. If $K(x_i,x_j)
      = 1/(x_j-x_i)$, then the operator might be calculating the force on a set of
      charged particles via a Coulomb force. If $K(x_i,x_j) = \sqrt{(x_j-x_i)^2 +
      c^2}$, then the operator might be used to for function interpolation using
      the multiquadric function.
    </p>
<p>
      One way to evaluate this operator is to use a matrix to store the values of
      $K(x_i,x_j)$ for each particle pair, leading to a matrix $\mathbf{K}$ with
      storage size $N^2$. Then the summation operator above is equivilent to the
      matrix-vector product
    </p>
<p>
      $$ \mathbf{a} = \mathbf{K} \mathbf{b}. $$
    </p>
<p>
      However, $\mathbf{K}$ could be too large to fit in memory, or the values of
      $x_i$ and $x_j$ might change too frequently for this to be useful. Or you may
      wish to take advantage of the fact that $K(x_i,x_j)$ is a continuous function
      and use method such as Chebyshev interpolation or Fast Multipole methods to
      calculate the operator efficiently. For any of these reasons you might want
      prefer matrix-free methods, and Aboria can help you do this.
    </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
        Currently Aboria only supports basic dense and sparse matrix-free operators
        based on local neighbourhood searches. A Chebyshev operator has been implemented,
        but this is still being tested, and the API is not stable, so is not documented.
        All going well, a Fast Multipole method (hopefully using a few different
        methods) will be implemented after this.
      </p></td></tr>
</table></div>
<p>
      To provide the concept and API of a matrix or linear operator, we will use
      the C++ library <a href="../eigen.tuxfamily.org" target="_top">Eigen</a>. Aboria provides
      functionality to wrap summation operators involving an arbitrary kernel $K()$
      in <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html" title="Class template MatrixReplacement">Aboria::MatrixReplacement</a></code>,
      so that Eigen can treat them as normal matricies.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.matrix_free_linear_algebra_with_.creating_dense_operators"></a><a class="link" href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.creating_dense_operators" title="Creating Dense Operators">Creating
      Dense Operators</a>
</h3></div></div></div>
<p>
        The most general case involves a summation kernel function $K$ that is non-zero
        for every possible particle pair. This kernel function can depend on the
        particle positions and/or the variables assigned to each particle. For example,
        say we had a particle set with particle positions $\mathbf{x}_i$ for $i=1..N$,
        and a single variable $a_i$. We wish to create a summation operator using
        the kernel function
      </p>
<p>
        $$ K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \frac{a_i a_j}{||\mathbf{x}_j-\mathbf{x}_i||
        + \epsilon} $$
      </p>
<p>
        were $||.||$ refers to the 2-norm, or magnitude of a vector.
      </p>
<p>
        First we need a particle set to apply the operator to. We will create a particle
        set containing $N=100$ particles with a single additional variable $a$.
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">N</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
<span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">epsilon</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>
<span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="keyword">double</span><span class="special">,</span><span class="string">"a"</span><span class="special">);</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;&gt;</span> <span class="identifier">particle_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">position</span> <span class="identifier">position</span><span class="special">;</span>
<span class="identifier">particle_type</span> <span class="identifier">particles</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">default_random_engine</span> <span class="identifier">gen</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">uniform_real_distribution</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">uniform</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">double3</span><span class="special">(</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        For convenience, we will also define a few types that we will need to define
        our kernel function. These will define a constant reference to the storage
        type used to store each particle positions, and a constant reference type
        to refer to each particle in the container
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">position</span><span class="special">::</span><span class="identifier">value_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">const_position_reference</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">const_reference</span> <span class="identifier">const_particle_reference</span><span class="special">;</span>
</pre>
<p>
        We then create a dense matrix-free summation operator using the <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        function
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">K</span> <span class="special">=</span> <span class="identifier">create_dense_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">i</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">j</span><span class="special">))</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        Note that <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        takes three arguments. The first two are particle containers which give the
        two particle sets involved in the operator. The first container holds the
        particles indexed by $i$ in the kernel function, and the second holds the
        particles indexed by $j$. For a matrix representation, you might say that
        these refer to the rows and columns of the matrix.
      </p>
<p>
        The third argument to <code class="computeroutput"><a class="link" href="../Aboria/create_dense_operator.html" title="Function template create_dense_operator">Aboria::create_dense_operator</a></code>
        can be a function object, or C++ lambda expression. Basically any valid C++
        object that can be called with three arguments, the first being of type
        <code class="computeroutput"><span class="identifier">const_position_reference</span></code>
        (i.e. a constant reference to the position type), the second of type <code class="computeroutput"><span class="identifier">const_particle_reference</span></code> (i.e. a constant
        reference to a particle in the set indexed by $i$), and the third of type
        <code class="computeroutput"><span class="identifier">const_particle_reference</span></code>
        (i.e. a constant reference to a particle in the set indexed by $j$). The
        first argument will contain the shortest vector between the particle pair
        given by $i,j$, and the second and third will be references to the particles
        $i$ and $j$. Note that in this case the particle sets indexed by $i$ and
        $j$ is the same particle set <code class="computeroutput"><span class="identifier">particles</span></code>.
        However, in other cases you may want $i$ and $j$ to index different particle
        sets, in which case the types for argument 2 and 3 could be different.
      </p>
<p>
        In the code above, we are using a lambda expression as our function object,
        and create one that returns the particular kernel function $K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)$.
      </p>
<p>
        Once we have created the operator <code class="computeroutput"><span class="identifier">K</span></code>,
        we can use it within Eigen as if it were a normal matrix. For example, to
        apply <code class="computeroutput"><span class="identifier">K</span></code> to a vector <code class="computeroutput"><span class="identifier">b</span></code>, we could write the following
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>
<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_1</span> <span class="special">=</span> <span class="identifier">K</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
<p>
        This line of code calculates the following
      </p>
<p>
        $$ c_i = \sum_j^N b_j K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) \text{ for } i=1..N
        $$
      </p>
<p>
        Note that rather then storing all the values of K that are needed for this
        summation, Aboria will instead evaluate these values as they are needed.
        Therefore the memory requirements are only $\mathcal{O}(N)$, rather than
        $\mathcal{O}(N^2)$ for a traditional matrix.
      </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          the matrix-free operator <code class="computeroutput"><span class="identifier">K</span></code>
          cannot be used, for example, in multiplications or additions with other
          Eigen matricies. Thus far, it has only really been tested with matrix-vector
          multiplication and Eigen's iterative solvers
        </p></td></tr>
</table></div>
<p>
        If we wish to perform the same operator, but using a traditional matrix,
        we can use <code class="computeroutput"><span class="identifier">K</span></code>'s <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html#idp47815184790928-bb">Aboria::MatrixReplacement::assemble</a></code>
        member function to fill in a normal Eigen matrix with the values of the kernel
        function $K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)$
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">MatrixXd</span> <span class="identifier">K_eigen</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">K</span><span class="special">.</span><span class="identifier">assemble</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_2</span> <span class="special">=</span> <span class="identifier">K_eigen</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.matrix_free_linear_algebra_with_.creating_sparse_operators"></a><a class="link" href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.creating_sparse_operators" title="Creating Sparse Operators">Creating
      Sparse Operators</a>
</h3></div></div></div>
<p>
        Is is common in particle-based methods that the kernel function $K$ be non-zero
        for particle pairs separated by less than a certain radius. In this case
        we have a summation operator like so
      </p>
<p>
        $$ c_i = \sum_j^N b_j K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) \text{ for }
        i=1..N $$
      </p>
<p>
        where $K_s$ is a truncated version of $K$ that is only non-zero for $||\mathbf{dx}_{ij}||&lt;r$,
        where $\mathbf{dx}_{ij}$ is the shortest vector between particles $i$ and
        $j$. Note that for non-periodic systems, this will be $\mathbf{dx}_{ij}=\mathbf{x}_j-\mathbf{x}_i$.
      </p>
<p>
        $$ K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \begin{cases} K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j),
        &amp; \text{for } ||\mathbf{dx}_{ij}||&lt;r \\\ 0 &amp; \text{otherwise}.
        \end{cases} $$
      </p>
<p>
        Since the summation is only non-zero for $||\mathbf{dx}_{ij}||&lt;r$, we
        wish to aim for better than $\mathcal{O}(N^2)$ time and combine the sum with
        a spatial search of radius $r$. Assuming the particle positions are uniformly
        distributed and that $r$ is much smaller than the domain size, this will
        result in $\mathcal{O}(1)$ particles within the search radius and the operator
        taking only $\mathcal{O}(N)$ time.
      </p>
<p>
        Lets assume that we wish a similar kernel function as before
      </p>
<p>
        $$ K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j) = \frac{a_i a_j}{||\mathbf{dx}_{ij}||
        + \epsilon} $$
      </p>
<p>
        We can create the operator <code class="computeroutput"><span class="identifier">K_s</span></code>
        in Aboria like so (setting $r=0.1$ in this case)
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">r</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">K_s</span> <span class="special">=</span> <span class="identifier">create_sparse_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">,</span>
        <span class="identifier">r</span><span class="special">,</span>
        <span class="special">[</span><span class="identifier">epsilon</span><span class="special">](</span><span class="identifier">const_position_reference</span> <span class="identifier">dx</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">i</span><span class="special">,</span>
           <span class="identifier">const_particle_reference</span> <span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">a</span><span class="special">&gt;(</span><span class="identifier">j</span><span class="special">))</span> <span class="special">/</span> <span class="special">(</span><span class="identifier">dx</span><span class="special">.</span><span class="identifier">norm</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">epsilon</span><span class="special">);</span>
        <span class="special">});</span>
</pre>
<p>
        When applied to a vector, this operator will use the neighbour search of
        the <code class="computeroutput"><span class="identifier">particles</span></code> container to
        perform a neighbour search for all particle pairs where $||\mathbf{dx}_{ij}||&lt;r$.
      </p>
<p>
        Before we can use this operator, we need to make sure that the neighbour
        search for <code class="computeroutput"><span class="identifier">particles</span></code> is initialised.
        By default, the particle container was created using three spatial dimensions,
        so we need to set up a domain with a given periodicity, and a search radius
        greater than or equal to $r$. Here we will setup a domain from $(0,0,0)$
        to $(1,1,1)$ which is not periodic in all directions.
      </p>
<pre class="programlisting"><span class="identifier">double3</span> <span class="identifier">min</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="identifier">double3</span> <span class="identifier">max</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">bool3</span> <span class="identifier">periodic</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span><span class="identifier">min</span><span class="special">,</span><span class="identifier">max</span><span class="special">,</span><span class="identifier">r</span><span class="special">,</span><span class="identifier">periodic</span><span class="special">);</span>
</pre>
<p>
        Once this is done, we can then apply the operator to the vector <code class="computeroutput"><span class="identifier">b</span></code> from before
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_3</span> <span class="special">=</span> <span class="identifier">K_s</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
<p>
        Once again, we can write out <code class="computeroutput"><span class="identifier">K_s</span></code>
        to a traditional matrix. This time, we will write out the values of <code class="computeroutput"><span class="identifier">K_s</span></code> to a sparse matrix, so we can still
        obtain an efficient operator
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">SparseMatrix</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">K_s_eigen</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">K_s</span><span class="special">.</span><span class="identifier">assemble</span><span class="special">(</span><span class="identifier">K_s_eigen</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">c_4</span> <span class="special">=</span> <span class="identifier">K_s_eigen</span><span class="special">*</span><span class="identifier">b</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.matrix_free_linear_algebra_with_.block_operators"></a><a class="link" href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.block_operators" title="Block Operators">Block
      Operators</a>
</h3></div></div></div>
<p>
        It is common that you would like to compose operators in a tiled or block
        format, and Aboria provides a functionality to do this using the <code class="computeroutput"><a class="link" href="../Aboria/create_block_operator.html" title="Function template create_block_operator">Aboria::create_block_operator</a></code>.
      </p>
<p>
        Let us assume that we wish to compose the two operators <code class="computeroutput"><span class="identifier">K</span></code>
        and <code class="computeroutput"><span class="identifier">K_s</span></code> from before, and
        want to perform the following combined operator
      </p>
<p>
        $$ \begin{align} e_i &amp;= \sum_j^N d_j K_s(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)
        \text{ for } i=1...N \\ e_{i+N} &amp;= \sum_j^N d_{j+N} K(\mathbf{x}_i,a_i,\mathbf{x}_j,a_j)
        \text{ for } i=1...N \end{align} $$
      </p>
<p>
        where $e_i$ and $d_j$ are elements of vectors $\mathbf{e}$ and $\mathbf{d}$
        of size $2N$. Using matrix notation, and using $\mathbf{K}$ and $\mathbf{K}_s$
        to represent the operators <code class="computeroutput"><span class="identifier">K</span></code>
        and <code class="computeroutput"><span class="identifier">K_s</span></code>, this is equivilent
        to
      </p>
<p>
        $$ \mathbf{e} = \begin{pmatrix} \mathbf{K}_s &amp; 0 \\\ 0 &amp; \mathbf{K}
        \end{pmatrix} \mathbf{d} $$
      </p>
<p>
        We first need operators representing the zero matricies in the upper right
        and lower left corners of the block operator. We create these in Aboria like
        so
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">Zero</span> <span class="special">=</span> <span class="identifier">create_zero_operator</span><span class="special">(</span><span class="identifier">particles</span><span class="special">,</span><span class="identifier">particles</span><span class="special">);</span>
</pre>
<p>
        and then we can create the block operator <code class="computeroutput"><span class="identifier">Full</span></code>
        like so
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">Full</span> <span class="special">=</span> <span class="identifier">create_block_operator</span><span class="special">&lt;</span><span class="number">2</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span>
                 <span class="identifier">K_s</span> <span class="special">,</span> <span class="identifier">Zero</span><span class="special">,</span>
                <span class="identifier">Zero</span> <span class="special">,</span>  <span class="identifier">K</span>
        <span class="special">);</span>
</pre>
<p>
        Finally we can create vectors <code class="computeroutput"><span class="identifier">e</span></code>
        and <code class="computeroutput"><span class="identifier">d</span></code> and apply the block
        operator
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">d</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">d</span><span class="special">.</span><span class="identifier">head</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>
<span class="identifier">d</span><span class="special">.</span><span class="identifier">tail</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span><span class="special">::</span><span class="identifier">LinSpaced</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1.0</span><span class="special">);</span>

<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">e</span> <span class="special">=</span> <span class="identifier">Full</span><span class="special">*</span><span class="identifier">d</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.matrix_free_linear_algebra_with_.iterative_solvers"></a><a class="link" href="matrix_free_linear_algebra_with_.html#aboria.matrix_free_linear_algebra_with_.iterative_solvers" title="Iterative Solvers">Iterative
      Solvers</a>
</h3></div></div></div>
<p>
        The <code class="computeroutput"><a class="link" href="../Aboria/MatrixReplacement.html" title="Class template MatrixReplacement">Aboria::MatrixReplacement</a></code>
        class can multiply other Eigen vectors, and can be used in Eigen's iterative
        solvers. Both <code class="computeroutput"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">IdentityPreconditioner</span></code> and <code class="computeroutput"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span></code> preconditioners
        are supported. Below is an example of how to use Eigen's GMRES iterative
        solver to solve the equation
      </p>
<p>
        $$\mathbf{c} = \mathbf{K} \mathbf{h}$$
      </p>
<p>
        for input vector $\mathbf{h}$.
      </p>
<p>
        We can simply pass the dense operator <code class="computeroutput"><span class="identifier">K</span></code>
        to Eigen's GMRES iterative solver like so
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">GMRES</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">K</span><span class="special">),</span>
    <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">gmres_matrix_free</span><span class="special">;</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">setMaxIterations</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">set_restart</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">compute</span><span class="special">(</span><span class="identifier">K</span><span class="special">);</span>
<span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">h_1</span> <span class="special">=</span> <span class="identifier">gmres_matrix_free</span><span class="special">.</span><span class="identifier">solve</span><span class="special">(</span><span class="identifier">c_1</span><span class="special">);</span>
</pre>
<p>
        This will solve the equation in a matrix-free fashion. Alternativly, we can
        use the normal matrix <code class="computeroutput"><span class="identifier">K_eigen</span></code>
        that we assembled previously to solve the equation
      </p>
<pre class="programlisting"><span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">GMRES</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">),</span>
     <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">DiagonalPreconditioner</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">gmres_matrix</span><span class="special">;</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">setMaxIterations</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">);</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">set_restart</span><span class="special">(</span><span class="number">2</span><span class="special">*</span><span class="identifier">N</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
 <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">compute</span><span class="special">(</span><span class="identifier">K_eigen</span><span class="special">);</span>
 <span class="identifier">Eigen</span><span class="special">::</span><span class="identifier">VectorXd</span> <span class="identifier">h_2</span> <span class="special">=</span> <span class="identifier">gmres_matrix</span><span class="special">.</span><span class="identifier">solve</span><span class="special">(</span><span class="identifier">c_1</span><span class="special">);</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015-2017 Martin Robinson</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="neighbourhood_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="symbolic_expressions.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
