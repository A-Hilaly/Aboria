<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Neighbourhood Searching</title>
<link rel="stylesheet" href="../css/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Aboria 0.4">
<link rel="up" href="../index.html" title="Aboria 0.4">
<link rel="prev" href="particle_container.html" title="Particle Container">
<link rel="next" href="matrix_free_linear_algebra_with_.html" title="Matrix-free Linear Algebra with Eigen">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
    },
  TeX: { 
    extensions: ["AMSmath.js", "AMSsymbols.js"] 
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48149829-4', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Aboria" width="200" height="62" src="../images/aboria2.jpg"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="particle_container.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="matrix_free_linear_algebra_with_.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="aboria.neighbourhood_searching"></a><a class="link" href="neighbourhood_searching.html" title="Neighbourhood Searching">Neighbourhood Searching</a>
</h2></div></div></div>
<p>
      The <code class="computeroutput"><a class="link" href="../Aboria/Particles.html" title="Class template Particles">Aboria::Particles</a></code> container
      gives you neighbourhood searching functionality, using a simple cell-list approach.
      The domain is divided into a regular grid of hypercubes with side length equal
      to a lengthscale that is supplied by the user. Each particle in the container
      is assigned to the cell that contains its position. Neighbourhood search queries
      at a given point return all the particles within the cell that contains this
      point and the immediate cell neighbours.
    </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
        v0.5 of Aboria will introduce a new and improved neighbourhood searching
        design, which also includes a k-d tree data structure for searching. The
        other "caution" messages below describe what will change
      </p></td></tr>
</table></div>
<p>
      To start with, we will create a particle set in three dimensions (the default)
      containing a few randomly placed particles
    </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">N</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;&gt;</span> <span class="identifier">particle_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">position</span> <span class="identifier">position</span><span class="special">;</span>
<span class="identifier">particle_type</span> <span class="identifier">particles</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">default_random_engine</span> <span class="identifier">gen</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">uniform_real_distribution</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">uniform</span><span class="special">(-</span><span class="number">1</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">double3</span><span class="special">(</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
      Here we use the default data structure for neighbourhood searching, which is
      a cell-list data structure that supports serial insertion of points, and parallel
      queries. You can explicitly choose this data structure like so:
    </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;&gt;,</span><span class="number">3</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">,</span><span class="identifier">bucket_search_serial</span><span class="special">&gt;</span> <span class="identifier">particle_bs_serial_type</span><span class="special">;</span>
</pre>
<p>
      You will notice that we also need to specify the vector data structure that
      the particle container uses, which in this case is a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>.
    </p>
<p>
      The alternative is a cell-list data structure that supports parallel insetion
      of points, and parallel queries. This constantly re-orders the particles in
      the particle container so that they are sorted into individual cells, so if
      particles are changing cells often this can be slower. But theoretically (this
      hasn't been tested yet) this should speed up neighbourhood search queries as
      the particles that are local in memory are also local in space. You can use
      this data structure like so:
    </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;&gt;,</span><span class="number">3</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">,</span><span class="identifier">bucket_search_parallel</span><span class="special">&gt;</span> <span class="identifier">particle_bs_parallel_type</span><span class="special">;</span>
</pre>
<p>
      Before you can use the neighbourhood searching, you need to initialise the
      domain using the <code class="computeroutput"><a class="link" href="../Aboria/Particles.html#idp46750534727360-bb">Aboria::Particles::init_neighbour_search</a></code>
      function.
    </p>
<p>
      In this case, we will initialise a domain from $(-1,-1,-1)$ to $(1,1,1)$, which
      is periodic in all directions. We will set the search radius to 0.2.
    </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
        This will change in v0.5 of Aboria, insead of setting a search radius you
        will specify a number of particles per unit cell of the neighbourhood search
        data structure (This also means you don't have to specify your maximum search
        radius here, which is annoying)
      </p></td></tr>
</table></div>
<pre class="programlisting"><span class="identifier">double3</span> <span class="identifier">min</span><span class="special">(-</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">double3</span> <span class="identifier">max</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">bool3</span> <span class="identifier">periodic</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
<span class="keyword">double</span> <span class="identifier">radius</span> <span class="special">=</span> <span class="number">0.2</span><span class="special">;</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span><span class="identifier">min</span><span class="special">,</span><span class="identifier">max</span><span class="special">,</span><span class="identifier">radius</span><span class="special">,</span><span class="identifier">periodic</span><span class="special">);</span>
</pre>
<p>
      Here <code class="computeroutput"><span class="identifier">radius</span></code> is the lengthscale
      of the neighbourhood search. That is, any particles that are separated by more
      than <code class="computeroutput"><span class="identifier">radius</span></code> might not be classified
      as neighbours.
    </p>
<p>
      Once this is done you can begin using the neighbourhood search queries using
      the <code class="computeroutput"><span class="identifier">box_search</span></code> function. This
      returns a lightweight container with <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code> functions that return <code class="computeroutput"><span class="keyword">const</span></code>
      forward only iterators to the particles that satisfy the neighbour search.
      For example, the following counts all the particles within a square domain
      of side length <code class="computeroutput"><span class="identifier">radius</span></code> of the
      point $(0,0,0)$
    </p>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
        This will change in v0.5 of Aboria, instead you will use a more generic distance
        search within a given maximum distance, from a given query point, where the
        distance metric can be L1 (manhatten distance) , L2 (euclidian distance)
        , ... , Linf (a box search region).
      </p></td></tr>
</table></div>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">count</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">auto</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">:</span> <span class="identifier">box_search</span><span class="special">(</span><span class="identifier">particles</span><span class="special">.</span><span class="identifier">get_query</span><span class="special">(),</span><span class="identifier">double3</span><span class="special">(</span><span class="number">0</span><span class="special">)))</span> <span class="special">{</span>
    <span class="identifier">count</span><span class="special">++;</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"There are "</span><span class="special">&lt;&lt;</span> <span class="identifier">count</span> <span class="special">&lt;&lt;</span> <span class="string">" particles.\n"</span><span class="special">;</span>
</pre>
<p>
      When dereferenced, the neighbourhood iterator returns a tuple of size 2 containing
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          A constant reference to the found particle object, with type <code class="computeroutput"><span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">const_reference</span></code>
        </li>
<li class="listitem">
          A vector $\mathbf{dx}_{ij}$ pointing to the found point from the query
          point. I.e. if $\mathbf{x}_i$ is the query point and $\mathbf{x}_j$ is
          the found point, then $\mathbf{dx}_{ij} = \mathbf{x}_j - \mathbf{x}_i$.
        </li>
</ol></div>
<p>
      The latter is useful for periodic domains, the returned vector $\mathbf{dx}_{ij}$
      takes periodic domains into account and returns the $\mathbf{dx}_{ij}$ with
      the smallest length.
    </p>
<p>
      For example,
    </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">auto</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">:</span> <span class="identifier">box_search</span><span class="special">(</span><span class="identifier">particles</span><span class="special">.</span><span class="identifier">get_query</span><span class="special">(),</span><span class="identifier">double3</span><span class="special">(</span><span class="number">0</span><span class="special">)))</span> <span class="special">{</span>
    <span class="identifier">particle_type</span><span class="special">::</span><span class="identifier">const_reference</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">);</span>
    <span class="keyword">const</span> <span class="identifier">double3</span><span class="special">&amp;</span> <span class="identifier">dx</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Found a particle with dx = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">dx</span> <span class="special">&lt;&lt;</span> <span class="string">" and id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015-2017 Martin Robinson</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="particle_container.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="matrix_free_linear_algebra_with_.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
