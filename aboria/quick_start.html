<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Quick Start</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Aboria 0.1">
<link rel="up" href="../index.html" title="Aboria 0.1">
<link rel="prev" href="../index.html" title="Aboria 0.1">
<link rel="next" href="examples.html" title="Examples">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Aboria" width="200" height="62" src="../images/aboria2.jpg"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="aboria.quick_start"></a><a class="link" href="quick_start.html" title="Quick Start">Quick Start</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.creating_new_particles">Creating new
      particles</a></span></dt>
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.particle_objects">Particle Objects</a></span></dt>
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.looping_through_the_container">Looping
      through the container</a></span></dt>
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.neighbourhood_searching">Neighbourhood
      Searching</a></span></dt>
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.variable_expression">Variable Expression</a></span></dt>
<dt><span class="section"><a href="quick_start.html#aboria.quick_start.neighbourhood_accumulation_expre">Neighbourhood
      Accumulation Expressions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.creating_new_particles"></a><a class="link" href="quick_start.html#aboria.quick_start.creating_new_particles" title="Creating new particles">Creating new
      particles</a>
</h3></div></div></div>
<p>
        The main particles data-structure, or container, is called <code class="computeroutput"><a class="link" href="../Aboria/Particles.html" title="Class template Particles">Particles</a></code>.
        It is templated on zero or more variable types. For example, the following
        creates a set of particles which each have (along with the standard variables
        such as position, id etc) a data package consisting of one double variable
        type named scalar.
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">Aboria</span><span class="special">;</span>

<span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">scalar</span><span class="special">,</span><span class="keyword">double</span><span class="special">,</span><span class="string">"my scalar"</span><span class="special">)</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">scalar</span><span class="special">&gt;</span> <span class="identifier">MyParticles</span><span class="special">;</span>
<span class="identifier">MyParticles</span> <span class="identifier">particles</span><span class="special">();</span>
</pre>
<p>
        If you wanted each particle to have a potential variable held as a <code class="computeroutput"><span class="keyword">double</span></code>, as well as a velocity variable held
        as a <code class="computeroutput"><a class="link" href="../index/s05.html#Aboria.Vect3d">Vect3d</a></code> vector class, then
        you would write the following
      </p>
<pre class="programlisting"><span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">potential</span><span class="special">,</span><span class="keyword">double</span><span class="special">,</span><span class="string">"potential energy"</span><span class="special">)</span>
<span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">velocity</span><span class="special">,</span><span class="identifier">Vect3d</span><span class="special">,</span><span class="string">"velocity"</span><span class="special">)</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">potential</span><span class="special">,</span><span class="identifier">velocity</span><span class="special">&gt;</span> <span class="identifier">MyParticles</span><span class="special">;</span>
<span class="identifier">MyParticles</span> <span class="identifier">particles</span><span class="special">();</span>
</pre>
<p>
        You can also give the <code class="computeroutput"><span class="identifier">MyParticles</span></code>
        constructor a single <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code> argument to set the random seed for the
        container:
      </p>
<pre class="programlisting"><span class="identifier">MyParticles</span> <span class="identifier">particles_with_seed</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
</pre>
<p>
        To create new particles simply use the <code class="computeroutput"><span class="identifier">value_type</span></code>
        of the container type. Each particle constructor takes a single <code class="computeroutput"><a class="link" href="../index/s05.html#Aboria.Vect3d">Vect3d</a></code> type for the particle position.
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">MyParticles</span><span class="special">::</span><span class="identifier">value_type</span> <span class="identifier">MyParticle</span><span class="special">;</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">MyParticle</span><span class="special">(</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">)));</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">MyParticle</span><span class="special">(</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">)));</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.particle_objects"></a><a class="link" href="quick_start.html#aboria.quick_start.particle_objects" title="Particle Objects">Particle Objects</a>
</h3></div></div></div>
<p>
        The <code class="computeroutput"><span class="identifier">value_type</span></code> of the <code class="computeroutput"><a class="link" href="../Aboria/Particles.html" title="Class template Particles">Particles</a></code> container is a data-structure
        representing each particle. By default each particle has a position, a unique
        id and a boolean flag indicating if this particle is active or not. Use
        <code class="computeroutput"><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;()</span></code>
        to access the position, <code class="computeroutput"><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;()</span></code> for the id and <code class="computeroutput"><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">alive</span><span class="special">&gt;()</span></code> for the alive flag.
      </p>
<pre class="programlisting"><span class="identifier">MyParticle</span><span class="special">&amp;</span> <span class="identifier">particle</span> <span class="special">=</span> <span class="identifier">particles</span><span class="special">[</span><span class="number">0</span><span class="special">];</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span><span class="string">"Position = "</span><span class="special">&lt;&lt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particle</span><span class="special">)</span> <span class="special">&lt;&lt;</span>
   <span class="string">". Id = "</span><span class="special">&lt;&lt;</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">particle</span><span class="special">)&lt;&lt;</span> <span class="string">". Particle is "</span><span class="special">;</span>
<span class="keyword">if</span> <span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">alive</span><span class="special">&gt;(</span><span class="identifier">particle</span><span class="special">))</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"alive. "</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"dead. "</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        You can access the data by templating the <code class="computeroutput"><span class="identifier">get</span></code>
        function with the variable type, for example
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"The scalar data is "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">scalar</span><span class="special">&gt;(</span><span class="identifier">particle</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.looping_through_the_container"></a><a class="link" href="quick_start.html#aboria.quick_start.looping_through_the_container" title="Looping through the container">Looping
      through the container</a>
</h3></div></div></div>
<p>
        You can use the indexing operator <code class="computeroutput"><span class="identifier">Operator</span><span class="special">[]</span></code> to simply loop through the container
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="identifier">i</span><span class="special">++)</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Accessing particle with id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">[</span><span class="identifier">i</span><span class="special">])</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Or you can use the normal STL <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code> functions that return random access iterators
        to the beginning and end of the container.
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="identifier">i</span><span class="special">++)</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Accessing particle with id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(*</span><span class="identifier">i</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Or
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span><span class="special">:</span> <span class="identifier">particles</span><span class="special">)</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Accessing particle with id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Or you can use the STL algorithm <code class="computeroutput"><span class="identifier">for_each</span></code>.
        If you are using a GCC compiler, you can turn on the parallel mode to enable
        this loop to be run in parallel
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><span class="identifier">particles</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="special">[](</span><span class="identifier">MyParticle</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Accessing particle with id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">});</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.neighbourhood_searching"></a><a class="link" href="quick_start.html#aboria.quick_start.neighbourhood_searching" title="Neighbourhood Searching">Neighbourhood
      Searching</a>
</h3></div></div></div>
<p>
        The <code class="computeroutput"><span class="identifier">Particles</span></code> container gives
        you neighbourhood searching functionality, using a simple Cell List or Linked-List
        approach. The domain is divided into a regular grid of cubes with side length
        equal to a constant lengthscale that is supplied by the user. Each particle
        in the container is assigned to the cell that contains its position. Neighbourhood
        search queries at a given point return all the particles within the cell
        that contains this point and the immediate cell neighbours.
      </p>
<p>
        Before you can use the neighbourhood searching, you need to initialise the
        domain using the <code class="computeroutput"><span class="identifier">init_neighbour_search</span></code>
        function
      </p>
<pre class="programlisting"><span class="identifier">Vect3d</span> <span class="identifier">min</span><span class="special">(-</span><span class="number">1</span><span class="special">,-</span><span class="number">1</span><span class="special">,-</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">Vect3d</span> <span class="identifier">max</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">1</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">Vect3b</span> <span class="identifier">periodic</span><span class="special">(</span><span class="keyword">true</span><span class="special">,</span><span class="keyword">true</span><span class="special">,</span><span class="keyword">true</span><span class="special">);</span>
<span class="keyword">double</span> <span class="identifier">diameter</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span><span class="identifier">min</span><span class="special">,</span><span class="identifier">max</span><span class="special">,</span><span class="identifier">diameter</span><span class="special">,</span><span class="identifier">periodic</span><span class="special">);</span>
</pre>
<p>
        Here <code class="computeroutput"><span class="identifier">diameter</span></code> is the lengthscale
        of the neighbourhood search. That is, any particles that are separated by
        more than <code class="computeroutput"><span class="identifier">diameter</span></code> might
        not be classified as neighbours.
      </p>
<p>
        Once this is done you can begin using the neighbourhood search queries using
        the <code class="computeroutput"><span class="identifier">get_neighbours</span></code> function.
        This returns a lightweight container with <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code> functions that return <code class="computeroutput"><span class="keyword">const</span></code>
        forward only iterators to the particles that satisfy the neighbour search.
        For example, the following counts all the particles within a square domain
        of side length <code class="computeroutput"><span class="identifier">diameter</span></code> of
        the point (0,0,0)
      </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">count</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span><span class="special">:</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">get_neighbours</span><span class="special">(</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">)))</span> <span class="special">{</span>
   <span class="identifier">count</span><span class="special">++;</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"There are "</span><span class="special">&lt;&lt;</span> <span class="identifier">count</span> <span class="special">&lt;&lt;</span> <span class="string">" particles.\n"</span><span class="special">;</span>
</pre>
<p>
        When dereferenced, the neighbourhood iterator returns a tuple of size 2 containing
      </p>
<p>
        1. The found particle object 2. $dx$, a vector pointing to the found point
        from the query point. I.e. if $x_a$ is the query point and $x_b$ is the found
        point, then $dx = x_a - x_b$.
      </p>
<p>
        The latter is useful for periodic domains, the returned vector $dx$ takes
        periodic domains into account and returns the $dx$ with the smallest length.
      </p>
<p>
        For example,
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span><span class="special">:</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">get_neighbours</span><span class="special">(</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">)))</span> <span class="special">{</span>
   <span class="keyword">const</span> <span class="identifier">MyParticle</span><span class="special">&amp;</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">tpl</span><span class="special">);</span>
   <span class="keyword">const</span> <span class="identifier">Vect3d</span><span class="special">&amp;</span> <span class="identifier">dx</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">tpl</span><span class="special">);</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Found a particle with dx = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">dx</span> <span class="special">&lt;&lt;</span> <span class="string">" and id = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">id</span><span class="special">&gt;(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.variable_expression"></a><a class="link" href="quick_start.html#aboria.quick_start.variable_expression" title="Variable Expression">Variable Expression</a>
</h3></div></div></div>
<p>
        To start using variable expressions, you first need to define a set of symbols
        to represent your variables, as well as labels to represent your particle
        set(s).
      </p>
<p>
        A symbol representing the variable <code class="computeroutput"><span class="identifier">position</span></code>
        is defined as
      </p>
<pre class="programlisting"><span class="identifier">Symbol</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;</span> <span class="identifier">p</span><span class="special">;</span>
</pre>
<p>
        A label representing the particle set <code class="computeroutput"><span class="identifier">particles</span></code>
        with type <code class="computeroutput"><span class="identifier">MyParticles</span></code> is
        defined as
      </p>
<pre class="programlisting"><span class="identifier">Label</span><span class="special">&lt;</span><span class="number">0</span><span class="special">,</span><span class="identifier">MyParticles</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">(</span><span class="identifier">particles</span><span class="special">);</span>
<span class="identifier">Label</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="identifier">MyParticles</span><span class="special">&gt;</span> <span class="identifier">b</span><span class="special">(</span><span class="identifier">particles</span><span class="special">);</span>
</pre>
<p>
        The first template argument is the <span class="bold"><strong>depth</strong></span>
        of the label, and the second is the type of the particle set label refers
        to.
      </p>
<p>
        Labels refer to a specific particle set at a given depth. For example, given
        a neighbour expression involving two particles from <code class="computeroutput"><span class="identifier">particles</span></code>,
        the label <code class="computeroutput"><span class="identifier">a</span></code> defined above
        would refer to the first particle, and <code class="computeroutput"><span class="identifier">b</span></code>
        would refer to the second.
      </p>
<p>
        Now we have defined our labels and symbols, we can create a simple expression
        to set the position of all particles to <code class="computeroutput"><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">)</span></code>
      </p>
<pre class="programlisting"><span class="identifier">p</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
</pre>
<p>
        Or we can add a constant value <code class="computeroutput"><span class="number">1</span></code>
        to each particle position
      </p>
<pre class="programlisting"><span class="identifier">p</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">p</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
        For symbols on the right hand side of the expression, we can drop the label
        for a more compact expression
      </p>
<pre class="programlisting"><span class="identifier">p</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">p</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
        Or simply use an increment expression
      </p>
<pre class="programlisting"><span class="identifier">p</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">+=</span> <span class="number">1</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.quick_start.neighbourhood_accumulation_expre"></a><a class="link" href="quick_start.html#aboria.quick_start.neighbourhood_accumulation_expre" title="Neighbourhood Accumulation Expressions">Neighbourhood
      Accumulation Expressions</a>
</h3></div></div></div>
<p>
        To write expressions involving neighbouring particles, we can define an accumulator,
        which takes a single template argument which is the function or functor to
        accumulate with. For example, the following defines a summation accumulator
        using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">plus</span></code>
      </p>
<pre class="programlisting"><span class="identifier">Accumulate</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">sum</span><span class="special">;</span>
</pre>
<p>
        We can use this to count the number of particles within a distance of <code class="computeroutput"><span class="number">2</span></code> of each individual particle, storing the
        result in a variable called <code class="computeroutput"><span class="identifier">count</span></code>.
      </p>
<pre class="programlisting"><span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">count</span><span class="special">,</span><span class="keyword">int</span><span class="special">,</span><span class="string">"number of surrounding particles"</span><span class="special">)</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">count</span><span class="special">&gt;</span> <span class="identifier">MyParticles</span><span class="special">;</span>
<span class="identifier">MyParticles</span> <span class="identifier">particles</span><span class="special">();</span>

<span class="comment">//add some particles</span>
<span class="special">...</span>

<span class="comment">//initialise neighbour searching</span>
<span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">,</span><span class="number">0</span><span class="special">),</span><span class="identifier">Vect3d</span><span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">1</span><span class="special">,</span><span class="number">1</span><span class="special">),</span><span class="number">4</span><span class="special">,</span><span class="identifier">Vect3b</span><span class="special">(</span><span class="keyword">false</span><span class="special">,</span><span class="keyword">false</span><span class="special">,</span><span class="keyword">false</span><span class="special">));</span>

<span class="comment">//define symbols and labels, and sum</span>
<span class="identifier">Symbol</span><span class="special">&lt;</span><span class="identifier">count</span><span class="special">&gt;</span> <span class="identifier">c</span><span class="special">;</span>
<span class="identifier">Label</span><span class="special">&lt;</span><span class="number">0</span><span class="special">,</span><span class="identifier">MyParticles</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">(</span><span class="identifier">particles</span><span class="special">);</span>
<span class="identifier">Label</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="identifier">MyParticles</span><span class="special">&gt;</span> <span class="identifier">b</span><span class="special">(</span><span class="identifier">particles</span><span class="special">);</span>
<span class="identifier">Accumulate</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">sum</span><span class="special">;</span>

<span class="comment">//count neighbouring particles within a distance of 2</span>
<span class="identifier">c</span><span class="special">[</span><span class="identifier">a</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span><span class="identifier">norm</span><span class="special">(</span><span class="identifier">dx</span><span class="special">)&lt;</span><span class="number">2</span><span class="special">,</span><span class="number">1</span><span class="special">)</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015 Martin Robinson</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
